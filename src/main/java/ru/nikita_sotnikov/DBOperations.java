package ru.nikita_sotnikov;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.BatchPreparedStatementSetter;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.TransactionException;
import org.springframework.transaction.support.TransactionTemplate;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Provides database operations for managing {@link Job} objects.
 * This includes inserting, updating, deleting, and retrieving job data
 * from the 'jobs' table. All synchronization operations are performed within a transaction.
 */
public class DBOperations {
    private static final Logger log = LoggerFactory.getLogger(DBOperations.class);
    private final String TABLE_NAME = "jobs";

    private final JdbcTemplate jdbcTemplate;
    private final TransactionTemplate transactionTemplate;

    /**
     * Constructs a new DBOperations instance with the given {@link JdbcTemplate} and {@link TransactionTemplate}.
     *
     * @param jdbcTemplate The {@link JdbcTemplate} to use for database interactions.
     * @param transactionTemplate The {@link TransactionTemplate} to manage transactions.
     */
    public DBOperations(JdbcTemplate jdbcTemplate, TransactionTemplate transactionTemplate) {
        this.jdbcTemplate = jdbcTemplate;
        this.transactionTemplate = transactionTemplate;
    }

    /**
     * Inserts a list of {@link Job} objects into the database.
     * The `id` field is auto-generated by the database.
     *
     * @param insertList A list of {@link Job} objects to be inserted.
     */
    public void insertJobs(List<Job> insertList) {
        jdbcTemplate.batchUpdate("INSERT INTO " + TABLE_NAME + " (dep_code, dep_job, description) VALUES (?, ?, ?)", new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                ps.setString(1, insertList.get(i).getDepCode());
                ps.setString(2, insertList.get(i).getDepJob());
                ps.setString(3, insertList.get(i).getDescription());
            }

            @Override
            public int getBatchSize() {
                return insertList.size();
            }
        });
    }

    /**
     * Updates a list of existing {@link Job} objects in the database.
     * The update is based on the `id` of the job, and only the `description` field is updated.
     *
     * @param updateList A list of {@link Job} objects to be updated.
     */
    public void updateJobs(List<Job> updateList) {
        jdbcTemplate.batchUpdate("UPDATE " + TABLE_NAME + " SET description=? WHERE id=?", new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                ps.setString(1, updateList.get(i).getDescription());
                ps.setInt(2, updateList.get(i).getId());
            }

            @Override
            public int getBatchSize() {
                return updateList.size();
            }
        });
    }

    /**
     * Deletes a list of {@link Job} objects from the database.
     * Deletion is based on the `id` of the job.
     *
     * @param deleteList A list of {@link Job} objects to be deleted.
     */
    public void deleteJobs(List<Job> deleteList) {
        jdbcTemplate.batchUpdate("DELETE FROM " + TABLE_NAME + " WHERE id = ?", new BatchPreparedStatementSetter() {
            @Override
            public void setValues(PreparedStatement ps, int i) throws SQLException {
                ps.setInt(1, deleteList.get(i).getId());
            }

            @Override
            public int getBatchSize() {
                return deleteList.size();
            }
        });
    }

    /**
     * Retrieves all {@link Job} objects from the database and returns them as a {@link Map}.
     * The map's keys are {@link JobKey} objects (composed of `depCode` and `depJob`),
     * and the values are the corresponding {@link Job} objects.
     *
     * @return A map of {@link JobKey} to {@link Job} objects representing the current state of the database.
     */
    public Map<JobKey, Job> getJobMap(){
        List<Job> result = getJobList();

        Map<JobKey, Job> jobsFromDB = new HashMap<>();

        for(Job job : result){
            jobsFromDB.put(new JobKey(job.getDepCode(), job.getDepJob()), job);
        }

        return jobsFromDB;
    }

    /**
     * Retrieves all {@link Job} objects from the database and returns them as a {@link List}.
     *
     * @return A list of all {@link Job} objects currently in the database.
     */
    public List<Job> getJobList(){
        List<Job> jobs = jdbcTemplate.query("SELECT * FROM " + TABLE_NAME, new JobMapper());

        log.info("Loaded {} jobs from database", jobs.size());

        return jobs;
    }

    /**
     * Refreshes the database by performing insertions, updates, and deletions in a single transaction.
     * If any operation within the transaction fails, the entire transaction is rolled back,
     * ensuring data consistency.
     *
     * @param insertList A list of {@link Job} objects to be inserted.
     * @param updateList A list of {@link Job} objects to be updated.
     * @param deleteList A list of {@link Job} objects to be deleted.
     */
    public void refreshDB(List<Job> insertList, List<Job> updateList, List<Job> deleteList) {
        log.info("Start transaction");

        try{
            transactionTemplate.execute(_ -> {
                insertJobs(insertList);
                updateJobs(updateList);
                deleteJobs(deleteList);

                return null;
            });

            log.info("Transaction successful");
        }
        catch(TransactionException e){
            log.error("Transaction error.", e);
        }
    }
}